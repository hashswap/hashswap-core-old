scilla_version 0

import BoolUtils IntUtils

library HashSwap

type Denom =
  | Husd of ByStr20 (* husd address *)
  | Token of ByStr20 (* token address / hash *)
type Coins = | Coins of Denom Uint128 (* denom, amount *)
type Pool = | Pool of Uint128 Uint128 (* x, y = husd reserve, token reserve *)
type StakingReward = | StakingReward of Uint128 BNum (* Stakig Reward, Last Staking Reward Block *)
type LiquidityToken = | LiquidityToken of Uint128 BNum (* Stakig Reward, Last Staking Reward Block *)
type Reward = | Reward of Uint128 StakingReward BNum (* Transaction Fee, Staking Reward, Pool Creation Block *)

let price_denom = Uint256 100 (* fee denominated in basis points (1 b.p. = 0.01%) *)

type SwapDirection = | HusdToToken | TokenToHusd
type ExactSide = | ExactInput | ExactOutput
type Swap = | Swap of (Option Pool) SwapDirection ExactSide Uint128 (Option Uint128) Uint256 
(* exact amt, limit amt, after fee amt *)
type ResultOrError =
 | Result of Pool Uint128 (* unwrapped pool, calculated amount *)
 | Error of String

let zero = Uint128 0
let one = Uint128 1
let true: Bool = True
let false: Bool = False
let zeroAddress: ByStr20 = 0x0000000000000000000000000000000000000000


(* Error events *)
type Error =
| DefaultError
| UnauthorizedOwner
| UnauthorizedSender
| SenderOwnerMismatch
| SenderLauncherMismatch
| UnauthorizedAddressMismatch
| UnauthorizedAddressMatch
| FlagIsTrue
| LinkInRegister
| LinkNotInRegister
| WalletIsRegistered
| WalletIsNotRegistered


let make_error =
fun (result : Error) =>
  let result_code = 
    match result with
    | DefaultError                      => Int32 0
    | UnauthorizedOwner                 =>  Int32 -11
    | UnauthorizedSender                => Int32 -12
    | SenderOwnerMismatch               => Int32 -30
    | SenderLauncherMismatch            => Int32 -31
    | UnauthorizedAddressMismatch       => Int32 -40
    | UnauthorizedAddressMatch          => Int32 -41
    | FlagIsTrue                        => Int32 -51
    | LinkInRegister                    => Int32 -60
    | LinkNotInRegister                 => Int32 -61
    | WalletIsRegistered                => Int32 -70
    | WalletIsNotRegistered             => Int32 -71
    end
  in
  let result_string : String = 
    match result with
    | DefaultError                      => "Error Never Called"
    | UnauthorizedOwner                 => "unauthorized sender owner"
    | UnauthorizedSender                => "unauthorized sender"
    | SenderOwnerMismatch               => "Sender Owner Mismatch"
    | SenderLauncherMismatch            => "Sender Launcher Mismatch"
    | UnauthorizedAddressMismatch       => "Unauthorized Address Mismatch"
    | UnauthorizedAddressMatch          => "Unauthorized Address Match"
    | FlagIsTrue                        => "Flag Is True"
    | LinkInRegister                    => "Link is already in registered map"
    | LinkNotInRegister                 => "Link is not in registered map"
    | WalletIsRegistered                => "Wallet_Token is already registered"
    | WalletIsNotRegistered             => "Wallet_Token is not registered"
    end
  in
  { _exception : result_string; code : result_code }
 


let min_liquidity = Uint128 1000000000000000 (* 1000 HUSD *)
let fee_denom = Uint256 10000 (* fee denominated in basis points (1 b.p. = 0.01%) *)
let husd_address = 0x5bd6972f41507b163e970577ed48f2b43eb9958f
let husd = Husd husd_address

let oneMsg : Message -> List Message =
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let grow : Uint128 -> Uint256 =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end


let ratio : Uint128 -> Uint128 -> Option Uint128 = 
  fun (n : Uint128) =>
  fun (d : Uint128) =>
    let big_n = grow n in
    let big_d = grow d in 
    let n_over_d = builtin div big_n big_d in
    builtin to_uint128 n_over_d
  
  
(* computes the amount of the fraction x / d that is in y *)
(* result = yd/x *)
let frac : Uint128 -> Uint128 -> Uint128 -> Option Uint128  =
  fun (d : Uint128) =>
  fun (x : Uint128) =>
  fun (y : Uint128) =>
    let big_x = grow x in
    let big_y = grow y in
    let big_d = grow d in
    let d_times_y = builtin mul big_d big_y in
    let d_times_y_over_x = builtin div d_times_y big_x in
    builtin to_uint128 d_times_y_over_x

let frac256 : Uint128 -> Uint256 -> Uint256 -> Option Uint128  =
  fun (a : Uint128) =>
  fun (d : Uint256) =>
  fun (k : Uint256) =>
    let big_a = grow a in
    let a_times_k = builtin mul big_a k in
    let a_times_k_over_d = builtin div a_times_k d in
    builtin to_uint128 a_times_k_over_d


(* computes the husd that should be taken from the husd reserve
    when the given token amount is added to the token reserve *)
(* i = Husd Amount Output
   i' = i*10000/k Before Fee Husd Output
   xy = (x-i')(y+d) 
   => i' = xd/(y+d) Before Fee Husd
   => i = i'k/10000  Exact Husd
   => i = xdk/10000*(y+d)
   k is after_fee = 9997 types
   10000 is fee denomz
   i = after fee input amount *) 
let outputHusdForExactInputToken : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Option Uint128 =
  fun (token_amount_u128 : Uint128) =>
  fun (token_reserve_u128 : Uint128) =>
  fun (husd_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let token_amount = grow token_amount_u128 in
    let token_reserve = grow token_reserve_u128 in
    let husd_reserve = grow husd_reserve_u128 in
    let token_amount_after_fee = builtin mul token_amount after_fee in (* dk *)
    let numerator = builtin mul husd_reserve token_amount_after_fee in (* xdk *)
    let denominator = 
      let d1 = builtin add token_reserve token_amount in (* y+d *)
      builtin mul d1 fee_denom in (* 10000*(y+d) *)
    let result = builtin div numerator denominator in
    builtin to_uint128 result

(* computes the token that should be added to token reserve
when given amount of husd should be taken from Husd reserve *)
(* i = Husd Amount Output
   i' = i*10000/k Before Fee Husd Output
   xy = (x-i')(y+d) 
   => d = i'y/(x-i')
   => d = yi*10000/(xk-i*10000)
   i = husd_amount to be taken out *) 
let inputTokenForExactOutputHusd : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Option Uint128 =
  fun (husd_amount_u128 : Uint128) =>
  fun (token_reserve_u128 : Uint128) =>
  fun (husd_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let husd_amount = grow husd_amount_u128 in
    let token_reserve = grow token_reserve_u128 in
    let husd_reserve = grow husd_reserve_u128 in
    let husd_amount_before_fee = builtin mul husd_amount fee_denom in (* i*10000 *)
    let numerator = builtin mul token_reserve husd_amount_before_fee in (* yi*10000 *)
    let denominator = 
      let d1 = builtin add husd_reserve after_fee in (* xk *)
      builtin sub d1 husd_amount_before_fee in (* xk - i*10000 *)
    let result = builtin div numerator denominator in
    builtin to_uint128 result


(* computes the husd that should be taken from the husd reserve
    when the given token amount is added to the token reserve *)
(* i = Husd Amount Input
   i' = ik/10000 After fee Husd Input
   xy = (x+i')(y-d) 
   => d = i'y/(x+i')
   => d = iky/(x*10000+ik)
   k is after_fee = 9997 types
   10000 is fee denom
   i = after fee input amount *) 
let outputTokenForExactInputHusd : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Option Uint128 =
  fun (husd_amount_u128 : Uint128) =>
  fun (token_reserve_u128 : Uint128) =>
  fun (husd_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let husd_amount = grow husd_amount_u128 in
    let token_reserve = grow token_reserve_u128 in
    let husd_reserve = grow husd_reserve_u128 in
    let husd_amount_after_fee = builtin mul husd_amount after_fee in (* ik *)
    let numerator = builtin mul token_reserve husd_amount_after_fee in (* iky *)
    let denominator = 
      let d1 = builtin mul husd_reserve fee_denom in (* x*100000 *)
      builtin add d1 husd_amount_after_fee in (* x*10000 + ik *)
    let result = builtin div numerator denominator in
    builtin to_uint128 result


(* computes the husd that should be taken from the husd reserve
    when the given token amount is added to the token reserve *)
(* i = Husd Amount Input
   i' = ik/10000 After fee Husd Input
   xy = (x+i')(y-d) 
   => i' = xd/(y-d)
   => i = xd*10000/k(y-d)
   k is after_fee = 9997 types
   10000 is fee denom
   i = after fee input amount *) 
let inputHusdForExactOutputToken : Uint128 -> Uint128 -> Uint128 -> Uint256 -> Option Uint128 =
  fun (token_amount_u128 : Uint128) =>
  fun (token_reserve_u128 : Uint128) =>
  fun (husd_reserve_u128 : Uint128) =>
  fun (after_fee : Uint256) =>
    let token_amount = grow token_amount_u128 in
    let token_reserve = grow token_reserve_u128 in
    let husd_reserve = grow husd_reserve_u128 in
    let token_amount_before_fee = builtin mul token_amount fee_denom in (* d*10000 *)
    let numerator = builtin mul husd_reserve token_amount_before_fee in
    let denominator = (* k(y-d) *)
      let d1 = builtin sub token_reserve token_amount in
      builtin mul d1 after_fee in
    let result = builtin div numerator denominator in
    builtin to_uint128 result


(* computes the corresponding input or output amount for
   the given exact output or input amount, pool, and direction *)
let amountFor : Pool -> SwapDirection -> ExactSide -> Uint128 -> Uint256 -> Option Uint128 =
  fun (pool : Pool) =>
  fun (swap_direction : SwapDirection) =>
  fun (exact_side : ExactSide) =>
  fun (exact_amount : Uint128) =>
  fun (after_fee : Uint256) =>
    match pool with
    | Pool husd_reserve token_reserve =>
      let calc = 
      fun (swap : SwapDirection) =>
      fun (exact: ExactSide) =>
      match exact with
      | ExactInput => 
        match swap with
        | HusdToToken => outputTokenForExactInputHusd
        | TokenToHusd => outputHusdForExactInputToken
        end
      | ExactOutput => 
        match swap with
        | HusdToToken => inputHusdForExactOutputToken
        | TokenToHusd => inputTokenForExactOutputHusd
        end
      end in
      calc swap_direction exact_side exact_amount token_reserve husd_reserve after_fee
    end

(* checks whether the result amount is within the user provided
   limit amount, which is dependent on whether the output or input
   result was the one being computed *)
   
(* If Input is fixed : Output > Limit *)
(* If Output is fixed : Input < Limit *)
let withinLimits : Uint128 -> Option Uint128 -> ExactSide -> Bool =
  fun (result_amount : Uint128) =>
  fun (maybe_limit_amount : Option Uint128) =>
  fun (exact_side : ExactSide) =>
    match maybe_limit_amount with
    | None => True
    | Some limit_amount =>
      match exact_side with
      | ExactInput =>
        (* we are given an exact input and are computing the output,
           which should be greater or equal to the limit *)
        uint128_ge result_amount limit_amount
      | ExactOutput =>
        (* we are given an exact output and are computing the input,
           which should be lower or equal to the limit *)
        uint128_ge limit_amount result_amount
      end
    end

(* computes the resultant amount for the given swap *)
let resultFor : Swap -> ResultOrError =
  fun (swap : Swap) =>
    match swap with
    | Swap maybe_pool direction exact_side exact_amount maybe_limit_amount after_fee =>
      match maybe_pool with
      | None =>
        let e = "MissingPool" in Error e
      | Some pool =>
        let maybe_amount = amountFor pool direction exact_side exact_amount after_fee in
        match maybe_amount with
        | None =>
          let e = "IntegerOverflow" in Error e
        | Some amount =>
          let within_limits = withinLimits amount maybe_limit_amount exact_side in
          match within_limits with
          | False =>
            let e = "RequestedRatesCannotBeFulfilled" in Error e
          | True =>
            Result pool amount
          end
        end
      end
    end

(* checks whether the given pool is empty based
   on where either of the token reserve amounts are zero *)
let poolEmpty : Pool -> Bool =
  fun (p : Pool) =>
    match p with
    | Pool x y =>
      let x_empty = builtin lt x one in
      let y_empty = builtin lt y one in
      orb x_empty y_empty
    end

contract HashSwap
(
  initial_owner : ByStr20,
  initial_fee : Uint256,
  inflation_rate : Uint256
)

with
  uint256_le initial_fee fee_denom
=>

field pools : Map ByStr20 Pool = Emp ByStr20 Pool
field balances : Map ByStr20 (Map ByStr20 LiquidityToken) = Emp ByStr20 (Map ByStr20 LiquidityToken)
field total_contributions : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field launcher_fee : Map ByStr20 Uint128 = Emp ByStr20 Uint128
field total_rewards : Map ByStr20 Reward = Emp ByStr20 Reward
field output_after_fee : Uint256 = builtin sub fee_denom initial_fee
field owner : ByStr20 = initial_owner
field pending_owner : ByStr20 = zeroAddress
field staking_rate : Uint256 = inflation_rate

(* Fix LAUNCHER address in HEX *)
field launcher_address : ByStr20 = zeroAddress
field launcher_address_called : Bool = False

field test : Uint128 = Uint128 120
 
(**************************************)
(*             Procedures             *)
(**************************************)


procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

procedure FlagIsFalse(flag : Bool)
  match flag with
  | True => 
    err = FlagIsTrue;
    ThrowError err
  | False =>
  end
end

procedure AddressMatch(yes : Bool, address1 : ByStr20, address2 : ByStr20, err1 : Error, err2 : Error)
  is_match = builtin eq address1 address2;
  match is_match with
  | True =>
    match yes with
    | True =>
    | False =>
      ThrowError err2
    end
  | False =>
    match yes with
    | True =>
      ThrowError err1
    | False =>
    end
  end
end


procedure MatchOwner(address : ByStr20)
  err1 = UnauthorizedOwner;
  err2 = DefaultError;
  current_owner <- owner;
  AddressMatch true current_owner address err1 err2
end

procedure OwnerIsSender()
  err1 = SenderOwnerMismatch;
  err2 = DefaultError;
  current_owner <- owner;
  AddressMatch true current_owner _sender err1 err2
end

procedure LauncherIsSender()
  err1 = SenderLauncherMismatch;
  err2 = DefaultError;
  launcher <- launcher_address;
  AddressMatch true launcher _sender err1 err2
end
(****************************************)


procedure ThrowIfExpired(deadline_block: BNum)
  current_block <- & BLOCKNUMBER;
  is_not_expired = builtin blt current_block deadline_block;
  match is_not_expired with
  | True =>
  | False =>
    e = { _exception : "TransactionExpired" };
    throw e
  end
end

procedure ThrowIfZero(number: Uint128)
  gt_zero = uint128_gt number zero;
  match gt_zero with
  | True =>
  | False =>
    e = { _exception : "InvalidParameter" };
    throw e
  end
end

procedure ThrowIfHusd(address : ByStr20)
  is_husd = builtin eq address husd_address;
  match is_husd with
  | False =>
  | True =>
    e = { _exception : "InvalidParameter" };
    throw e
  end
end

procedure ThrowUnlessSenderIsOwner()
  current_owner <- owner;
  is_owner = builtin eq _sender current_owner;
  match is_owner with
  | True =>
  | False =>
    e = { _exception : "InvalidSender" };
    throw e
  end
end

procedure Send(coins : Coins, to_address : ByStr20)
  match coins with
  | Coins denom amount =>
    match denom with
    | Husd husd =>
      msg_to_husd = { 
        _tag : "Transfer"; _recipient: husd; _amount: zero;
        to: to_address; amount: amount };
      msgs = oneMsg msg_to_husd;
      send msgs
    | Token token =>
      msg_to_token =  {
        _tag : "Transfer"; _recipient: token; _amount: zero;
        to: to_address; amount: amount
      };
      msgs = oneMsg msg_to_token;
      send msgs
    end
  end
end

procedure Receive(coins : Coins)
  match coins with
  | Coins denom amount =>
    match denom with
    | Husd husd =>
      msg_to_token = {
        _tag : "TransferFrom"; _recipient: husd; _amount: zero;
        from: _sender; to: _this_address; amount: amount
      };
      msgs = oneMsg msg_to_token;
      send msgs
    | Token token =>
      msg_to_token = {
        _tag : "TransferFrom"; _recipient: token; _amount: zero;
        from: _sender; to: _this_address; amount: amount
      };
      msgs = oneMsg msg_to_token;
      send msgs
    end
  end
end


procedure CalculateActualHusdAmount(
  pool : Pool,
  token_address : ByStr20,
  input_husd : Bool,
  husd_amount : Uint128,
  token_amount : Uint128
)
  
  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
    e = { _exception : "MissingContributions" };
    throw e
  | Some total_contribution =>
    launcher <- launcher_address;
    maybe_launcher_contribution <- balances[token_address][launcher];
    match maybe_launcher_contribution with 
    | None =>
    | Some launcher_contribution =>
      match launcher_contribution with
      | LiquidityToken launcher_liquidity launcher_block =>
        match pool with
        | Pool x y => (* husd reserve, token reserve *)
          match input_husd with
          | True => 
                
            some_total_transaction_fee = frac256 husd_amount fee_denom initial_fee;
            match some_total_transaction_fee with
            | None =>
            | Some total_transaction_fee => 
              some_launcher_transaction_fee = frac total_transaction_fee total_contribution launcher_liquidity;
              match some_launcher_transaction_fee with
              | None =>
              | Some launcher_transaction_fee => 
                actual_husd = builtin sub husd_amount launcher_transaction_fee;
            
                new_pool =
                  let new_x = builtin add x actual_husd in
                  let new_y = builtin sub y token_amount in
                Pool new_x new_y;
                pools[token_address] := new_pool;
                
                some_launcher_fee_pool <- launcher_fee[token_address];
                match some_launcher_fee_pool with
                | None =>
                | Some launcher_fee_pool =>
                  (* TRansaction fee difference between input_amount actual_input *)
                  new_launcher_fee_pool = builtin add launcher_fee_pool launcher_transaction_fee;
                  launcher_fee[token_address] :=  new_launcher_fee_pool
                end
              end
            end

          | False =>
                
            after_fee <- output_after_fee;
            some_total_transaction_fee = frac256 husd_amount after_fee initial_fee;
            match some_total_transaction_fee with
            | None =>
            | Some total_transaction_fee => 
              some_launcher_transaction_fee = frac total_transaction_fee total_contribution launcher_liquidity;
              match some_launcher_transaction_fee with
              | None =>
              | Some launcher_transaction_fee => 
                actual_husd = builtin add husd_amount launcher_transaction_fee;
            
                new_pool =
                  let new_x = builtin sub x actual_husd in
                  let new_y = builtin add y token_amount in
                Pool new_x new_y;
                pools[token_address] := new_pool;
                  
                some_launcher_fee_pool <- launcher_fee[token_address];
                match some_launcher_fee_pool with
                | None =>
                | Some launcher_fee_pool =>
                  (* TRansaction fee difference between input_amount actual_input *)
                  new_launcher_fee_pool = builtin add launcher_fee_pool launcher_transaction_fee;
                  launcher_fee[token_address] :=  new_launcher_fee_pool
                end
              end
            end
            
          end
        end
      end
    end
  end
end

procedure DoSwap(
  pool : Pool,
  token_address : ByStr20,
  input : Coins,
  output : Coins,
  input_from : ByStr20,
  output_to : ByStr20
)

  e = {_eventname : "Inside: DoSwap transition 11111111 "};
  event e;


  after_fee <- output_after_fee;
  match pool with
  | Pool x y => (* husd reserve, token reserve *)

    
    e1 = {_eventname : "Inside: DoSwap transition 222222222 "};
    event e1;

    (* update new pool balances *)
    match input with
    | Coins input_denom input_amount =>

      e2 = {_eventname : "Inside: DoSwap transition INPUT COIN "; input_denom : input_denom; input_amount : input_amount};
      event e2;

      match output with
      | Coins output_denom output_amount =>
            
        e3 = {_eventname : "Inside: DoSwap transition OUTPUT COIN "; output_denom : output_denom; output_amount : output_amount};
        event e3;
            
        match input_denom with
        | Husd husd =>
          CalculateActualHusdAmount pool token_address true input_amount output_amount
        | Token t =>
          CalculateActualHusdAmount pool token_address false output_amount input_amount
        end 
      end
    end;
    
    (* do receive / send *)
    sending_from_self = builtin eq input_from _this_address;
    match sending_from_self with
    | True => (* don't do anything on internal send *)
    | False => Receive input (* accept the expected input *)
    end;

    sending_to_self = builtin eq output_to _this_address;
    match sending_to_self with
    | True => (* don't do anything on internal receive *)
    | False => Send output output_to (* send the expected output *)
    end;

    (* emit swap event *)
    e4 = {
      _eventname: "Swapped";
      pool: token_address; address: _sender;
      input: input; output: output
    };
    event e4
  end
end

(* helper procedure to do swap twice, first to internally
   swap to an intermediate husd amount with pool0 and then
   to swap that husd with pool1 to the _sender *)
procedure DoSwapTwice(
  pool0 : Pool,
  token0_address : ByStr20,
  pool1 : Pool,
  token1_address : ByStr20,
  input_amount : Uint128,
  intermediate_amount : Uint128,
  output_amount : Uint128,
  recipient_address : ByStr20
)
  input = let token0 = Token token0_address in
    Coins token0 input_amount;
  intermediate = Coins husd intermediate_amount;
  output = let token1 = Token token1_address in
    Coins token1 output_amount;
  DoSwap
    pool0
    token0_address
    input
    intermediate
    _sender
    _this_address
  ;
  DoSwap
    pool1
    token1_address
    intermediate
    output
    _this_address
    recipient_address
end

procedure SwapUsingHUSD(
  token_address : ByStr20,
  direction : SwapDirection,
  exact_side : ExactSide,
  exact_amount : Uint128,
  limit_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  ThrowIfExpired deadline_block;
  ThrowIfZero exact_amount;
  ThrowIfZero limit_amount;

  e5 = {_eventname : "Inside: First Test " };
  event e5;

  after_fee <- output_after_fee;
  maybe_pool <- pools[token_address];
  result =
    let option_limit_amount = Some {Uint128} limit_amount in
    let swap = Swap maybe_pool direction exact_side exact_amount option_limit_amount after_fee in
    resultFor swap;

  match result with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Result pool calculated_amount =>
    token = Token token_address;
    match exact_side with
    | ExactInput =>
     
      match direction with
      | HusdToToken =>
        input = Coins husd exact_amount;
        output = Coins token calculated_amount;
        
        e = {_eventname : "Inside: ExactInput and HusdToToken "; fee: calculated_amount };
        event e;
          
        DoSwap pool token_address input output _sender recipient_address
        
        
      | TokenToHusd =>
        input = Coins token exact_amount;
        output = Coins husd calculated_amount;
        DoSwap pool token_address input output _sender recipient_address
      end
    | ExactOutput =>
      match direction with
      | HusdToToken =>
        input = Coins husd calculated_amount;
        output = Coins token exact_amount;
        
        e = {_eventname : "Inside: ExactOutput and HusdToToken "; fee: calculated_amount };
        event e;
        DoSwap pool token_address input output _sender recipient_address
      | TokenToHusd =>
        input = Coins token calculated_amount;
        output = Coins husd exact_amount;
        
        e = {_eventname : "Inside: ExactOutput and HusdToToken "; fee: calculated_amount };
        event e
        (* DoSwap pool token_address input output _sender recipient_address *)
      end
    end
  end
end


(* Called by Owner only (precaution) *)
(* Self Locking with Register *)
(* Register is deployed before Launcher *)
(* To set the launcher address in Register this transition is called *)
(* This transition requires owner of REGISTER and LAUNCHER to be SAME *)
transition SetHEXAddressState ()

  (* Sender should be same as Owner *)
  OwnerIsSender;
  
      (* owner_register is set as _sender not owner (obsessive double check) *)
      husd_msg = {_tag : "setHEXAddress"; _recipient : husd_address; _amount : zero; 
      sender_owner : _sender};
      msgs = oneMsg husd_msg;
      
      send msgs
  
end



(* This transition is called ONE time *)
(* Only Launcher can call this transition *)
(* Owner of Launcher and HEX Should be SAME *)
(* Launcher Address is hardcoded in HEX *)
transition setLauncherAddress( sender_owner: ByStr20 )
  
    (* Owner of Launcher contract should be same as owner *)
    MatchOwner sender_owner;

      (* If register flag is false then set register_address field to sender *)
      address_flag <- launcher_address_called;
      FlagIsFalse address_flag;
      
          launcher_address_called := true;
          launcher_address := _sender;
          e = {_eventname : "launcher_contract_address_set_forever"};
          event e
      
  end

transition RecipientAcceptTransferFrom(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
  is_valid_transfer_to_self =
    let self_triggered = builtin eq initiator _this_address in
    let is_transfer_to_self = builtin eq recipient _this_address in
    andb self_triggered is_transfer_to_self;

  match is_valid_transfer_to_self with
  | False =>
    e = { _exception : "InvalidInvocation" };
    throw e
  | True => (* noop *)
  end
end

transition TransferFromSuccessCallBack(
  initiator : ByStr20,
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

transition TransferSuccessCallBack(
  sender : ByStr20,
  recipient : ByStr20,
  amount : Uint128
)
end

transition SetFee(
  new_fee : Uint256
)
  ThrowUnlessSenderIsOwner;
  is_valid_fee = uint256_le new_fee fee_denom;
  match is_valid_fee with
  | False =>
    e = { _exception : "InvalidParameter" };
    throw e
  | True =>
    new_output_after_fee = builtin sub fee_denom new_fee;
    output_after_fee := new_output_after_fee;
    e = { _eventname: "FeeSet"; fee: new_fee };
    event e
  end
end

transition TransferOwnership(
  new_owner : ByStr20
)
  ThrowUnlessSenderIsOwner;
  existing_owner <- owner;
  new_owner_is_existing_owner = builtin eq new_owner existing_owner;
  match new_owner_is_existing_owner with
  | True =>
    e = { _exception : "InvalidParameter" };
    throw e
  | False =>
    pending_owner := new_owner
  end
end

transition AcceptPendingOwnership()
  new_owner <- pending_owner;
  sender_is_pending_owner = builtin eq _sender new_owner;
  match sender_is_pending_owner with
  | False =>
    e = { _exception : "InvalidSender" };
    throw e
  | True =>
    owner := new_owner;
    pending_owner := husd_address;
    e = { _eventname: "OwnershipTransferred"; owner: new_owner };
    event e
  end
end


(* Launcher is launching a NEW sponsor pool for trading on HEX *)
(* Only Launcher can call this transition *)
transition launchSponsorPool(
  token_address : ByStr20,
  husd_amount : Uint128,
  token_amount: Uint128
)

  launcher <- launcher_address;
  launcherIsSender = builtin eq launcher _sender;
  match launcherIsSender with
  | False =>
  | True =>
    
    (* Accept husd amount *)
    husd_in = Coins husd husd_amount;
    Receive husd_in;
    
    (* Accept token amount *)
    token = Token token_address;
    tokens_in = Coins token token_amount;
    Receive tokens_in;
    
    (* Create NEW pool record *)
    new_pool = Pool husd_amount token_amount;
    pools[token_address] := new_pool;
    e1 = { _eventname: "PoolCreated"; pool: token_address };
    event e1;

    current_block <- & BLOCKNUMBER;
    liquidity_token = 
      let husd_liquidity = husd_amount in
      let liquidity_block =  current_block in 
      LiquidityToken husd_liquidity liquidity_block;
    balances[token_address][_sender] := liquidity_token;
    total_contributions[token_address] := husd_amount;
    e2 = { _eventname: "Mintederer77777777"; pool: token_address; address: _sender; amount: husd_amount };
    event e2;

    e4 = { _eventname: "PoolRewardSetToBESET"; pool: token_address };
    event e4;
  
    (* Create a record in launcher_fee map *)
    new_pool_launcher_fee = zero;
    launcher_fee[token_address] :=  new_pool_launcher_fee
    
  end
end

(* Pay Staking Rewaards earned thus far back to lp provider *)
procedure payStakingReward (
  current_block : BNum,
  last_block : BNum,
  maybe_husd_amount : Option Uint128,
  sender : ByStr20
)

  time_since_last_block_int256 = builtin bsub current_block last_block;
  maybe_time_since_last_block = builtin to_uint128 time_since_last_block_int256;
  match maybe_time_since_last_block with
  | None =>
  | Some time_since_last_block => 
    reward_rate <- staking_rate;
    maybe_staking_reward_per_token = frac256 time_since_last_block fee_denom reward_rate;
    match maybe_staking_reward_per_token with
    | None =>
    | Some staking_reward_per_token =>
      staking_reward = 
      match maybe_husd_amount with
      | None => zero
      | Some husd_amount => builtin mul husd_amount staking_reward_per_token
      end;
      pay_staking_rewards_msg = {_tag : "payStakingRewardHEX"; 
        _recipient : husd_address; _amount : zero; 
        staking_reward : staking_reward; receiver : sender };
      msgs = oneMsg pay_staking_rewards_msg;
      send msgs
    end 
  end
end


(* HUSDSWAP: Add Liquidity either add liquidity or create a new pool *)
(* HASHSWAP: Add Liquidity only add liquidity to a pool *)
(* Adding a pool is done only by LAUNCHER *)
transition AddLiquidity(
  token_address : ByStr20,
  min_contribution_amount : Uint128,
  husd_amount: Uint128,
  max_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfHusd token_address;
  ThrowIfZero husd_amount;
  ThrowIfZero max_token_amount;

  token = Token token_address;

  maybe_pool <- pools[token_address];
  match maybe_pool with
  | None => (* New pool can't be created. Maybe FUTURE UPDATE *)
  | Some pool =>
    match pool with
    | Pool x y => (* husd reserve, token reserve *)

      (* dY = dX * Y / X *)
      (* dX is always the QA transferred *)
      (* Token_amount = husd_amount*(token_reserve)/(husd_reserve) *)
      maybe_result = frac husd_amount x y;
      match maybe_result with
      | None =>
        e = { _exception : "IntegerOverflow" };
        throw e
      | Some result =>
        delta_y = builtin add result one;
        maybe_total_contribution <- total_contributions[token_address];
        match maybe_total_contribution with
        | None =>
          e = { _exception : "MissingContributions" };
          throw e
        | Some total_contribution =>
          maybe_new_contribution = frac husd_amount x total_contribution;
          match maybe_new_contribution with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some new_contribution =>
            within_limits =
              let token_lte_max = uint128_le delta_y max_token_amount in
              let contribution_gte_max = uint128_ge new_contribution min_contribution_amount in
              andb token_lte_max contribution_gte_max;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" ; delta_y: delta_y };
              throw e
            | True =>
              
              (* accept all husd *)
              husd_in = Coins husd husd_amount;
              Receive husd_in;
              
              (* accepts calculated tokens *)
              tokens_in = Coins token delta_y;
              Receive tokens_in;

              new_pool =
                let new_x = builtin add x husd_amount in
                let new_y = builtin add y delta_y in
                Pool new_x new_y;
              pools[token_address] := new_pool;

              existing_lp <- balances[token_address][_sender];
              
              current_block <- & BLOCKNUMBER;
              match existing_lp with
              | Some lp =>
                match lp with
                | LiquidityToken last_liquidity last_block =>
                  new_liquidity_token = 
                    let new_liquidity = builtin add last_liquidity new_contribution in
                    let new_block =  current_block in 
                  LiquidityToken new_liquidity new_block;
                  balances[token_address][_sender] := new_liquidity_token;
                  
                  (* Pay Staking Rewards earned thus far by LP provider *)
                  last_husd_contribution = frac x total_contribution last_liquidity;
                  payStakingReward current_block last_block last_husd_contribution _sender 
            
                end
              | None =>
                new_liquidity_token = 
                  let husd_liquidity = new_contribution in
                  let liquidity_block = current_block in 
                LiquidityToken husd_liquidity liquidity_block;
                balances[token_address][_sender] := new_liquidity_token
              end;

              new_total_contribution = builtin add total_contribution new_contribution;
              total_contributions[token_address] := new_total_contribution;

              e = { _eventname: "Mint"; pool: token_address; address: _sender; amount: new_contribution };
              event e
            end
          end
        end
      end
    end
  end
end


(* This procedure calculates and pay the total share of fee and staking rewards
earned by a investor with share ratio and time ratio *)
procedure SponsorFeeRewards(
 token_address : ByStr20,
 sponsor_tokens : Uint128,
 total_sponsor_tokens : Uint128,
 option_sponsor_entry_block : Option BNum,
 investor_address : ByStr20
)

  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
  | Some total_contribution =>
    launcher <- launcher_address;
    some_launcher_lp <- balances[token_address][launcher];
    match some_launcher_lp with
    | None =>
    | Some launcher_lp =>
      match launcher_lp with
      | LiquidityToken launcher_liquidity launcher_block =>
        
        some_sponsor_token_ratio = ratio sponsor_tokens total_sponsor_tokens;
        match some_sponsor_token_ratio with
        | None => 
        | Some sponsor_token_ratio =>
          
          current_block <- & BLOCKNUMBER;
          total_ratio = 
            let c_block = current_block in
            let time_ratio_num = 
              match option_sponsor_entry_block with
              | None => builtin bsub current_block launcher_block
              | Some sponsor_entry_block => builtin bsub current_block sponsor_entry_block
              end in
            let time_ratio_den = builtin bsub current_block launcher_block in
            let time_ratio_i256 = builtin div time_ratio_num time_ratio_den in 
            let option_time_ratio_u128 = builtin to_uint128 time_ratio_i256 in
            match option_time_ratio_u128 with
            | None => zero
            | Some time_ratio_u128 =>
              builtin mul sponsor_token_ratio time_ratio_u128
            end;
        
          (* Pay the transaction fee *)
          maybe_launcher_fee_pool <- launcher_fee[token_address];
          match maybe_launcher_fee_pool with      
          | None =>
          | Some launcher_fee_pool =>
            sponsor_fee_amount =  builtin mul total_ratio launcher_fee_pool;
            
            (* Send money to investor *)
            sponsor_fee = Coins husd sponsor_fee_amount;
            Send sponsor_fee investor_address
    
          end
        end
      end
    end
  end
end

(* To pay all fee and rewards for sponsors*)
(* This transition can only be called by Launcher *)
transition RedeemSponsorFeeRewards(
  token_address : ByStr20,
  sponsor_token : Uint128,
  total_sponsorship : Uint128,
  option_entry_block : Option BNum
)

  LauncherIsSender;
  launcher <- launcher_address;
   (* Calculate and Pay Transaction Fee too withdrawing sponsor *)
    SponsorFeeRewards token_address sponsor_token total_sponsorship option_entry_block launcher
end





transition RemoveSponsorLiquidity(
  token_address : ByStr20,
  husd_amount : Uint128,
  sponsor_address: ByStr20,
  influencer_wallet: ByStr20
)

  (* Only Launcher can call this *)
  (* deadline block is not required  because amount is directly in husd and not lp tokens *)
  LauncherIsSender;
  
  ThrowIfZero husd_amount;

  token = Token token_address;
  
  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some total_contribution =>
    ThrowIfZero total_contribution;
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* husd reserve, token reserve *)
        maybe_contribution_amount = frac husd_amount x total_contribution;
        maybe_token_amount = frac husd_amount x y;
        match maybe_contribution_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some contribution_amount =>
          match maybe_token_amount with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some token_amount => 
            
            maybe_launcher_lp <- balances[token_address][_sender];
            match maybe_launcher_lp with
            | None =>
              e = { _exception : "MissingBalance" };
              throw e
            | Some launcher_lp =>
              new_pool =
                let new_x = builtin sub x husd_amount in
                let new_y = builtin sub y token_amount in
              Pool new_x new_y;
              
              current_block <- & BLOCKNUMBER;
              match launcher_lp with
              | LiquidityToken last_liquidity last_block =>
                new_liquidity_token = 
                  let new_liquidity = builtin sub last_liquidity contribution_amount in
                  LiquidityToken new_liquidity last_block;
                balances[token_address][_sender] := new_liquidity_token;
                  

                is_pool_now_empty = poolEmpty new_pool;
                match is_pool_now_empty with
                | True =>
                  (* clear pool entries when there is no more liquidity *)
                  delete pools[token_address];
                  delete balances[token_address];
                  delete total_contributions[token_address]
                | False =>
                  pools[token_address] := new_pool;
                  new_total_contribution = builtin sub total_contribution contribution_amount;
                  total_contributions[token_address] := new_total_contribution
                end;

                husd_out = Coins husd husd_amount;
                tokens_out = Coins token token_amount;
                Send husd_out sponsor_address;
                Send tokens_out influencer_wallet;
  
                e = { _eventname: "Burnt"; pool: token_address; address: _sender; amount: contribution_amount };
                event e
              end
            end
          end
        end
      end
    end
  end
end


transition RemoveLiquidity(
  token_address : ByStr20,
  contribution_amount : Uint128,
  min_husd_amount : Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum
)
  ThrowIfExpired deadline_block;
  ThrowIfZero contribution_amount;
  ThrowIfZero min_husd_amount;
  ThrowIfZero min_token_amount;

  token = Token token_address;

  maybe_total_contribution <- total_contributions[token_address];
  match maybe_total_contribution with
  | None =>
    e = { _exception : "MissingPool" };
    throw e
  | Some total_contribution =>
    ThrowIfZero total_contribution;
    maybe_pool <- pools[token_address];
    match maybe_pool with
    | None =>
      e = { _exception : "MissingPool" };
      throw e
    | Some pool =>
      match pool with
      | Pool x y => (* husd reserve, token reserve *)
        maybe_husd_amount = frac contribution_amount total_contribution x;
        maybe_token_amount = frac contribution_amount total_contribution y;
        match maybe_husd_amount with
        | None =>
          e = { _exception : "IntegerOverflow" };
          throw e
        | Some husd_amount =>
          match maybe_token_amount with
          | None =>
            e = { _exception : "IntegerOverflow" };
            throw e
          | Some token_amount =>
            within_limits =
              let husd_ok = uint128_ge husd_amount min_husd_amount in
              let token_ok = uint128_ge token_amount min_token_amount in
              andb husd_ok token_ok;
            match within_limits with
            | False =>
              e = { _exception : "RequestedRatesCannotBeFulfilled" };
              throw e
            | True =>
              existing_balance <- balances[token_address][_sender];
              match existing_balance with
              | None =>
                e = { _exception : "MissingBalance" };
                throw e
              | Some lp =>
                
                new_pool =
                  let new_x = builtin sub x husd_amount in
                  let new_y = builtin sub y token_amount in
                  Pool new_x new_y;
                  
                current_block <- & BLOCKNUMBER;
                match lp with
                | LiquidityToken last_liquidity last_block =>
                  new_liquidity_token = 
                    let new_liquidity = builtin sub last_liquidity contribution_amount in
                    let new_block = current_block in 
                    LiquidityToken new_liquidity new_block;
                  balances[token_address][_sender] := new_liquidity_token;
                  
                  (* Check if pool is empty or not *)
                  is_pool_now_empty = poolEmpty new_pool;
                  match is_pool_now_empty with
                  | True =>
                    (* clear pool entries when there is no more liquidity *)
                    delete pools[token_address];
                    delete balances[token_address];
                    delete total_contributions[token_address]
                  | False =>
                    pools[token_address] := new_pool;
                    new_total_contribution = builtin sub total_contribution contribution_amount;
                    total_contributions[token_address] := new_total_contribution
                  end;

                  (* Pay back the principal amount *)
                  husds_out = Coins husd husd_amount;
                  tokens_out = Coins token token_amount;
                  Send husds_out _sender;
                  Send tokens_out _sender;
                
                  (* Pay Staking Rewards earned thus far by LP provider *)
                  last_husd_contribution = frac x total_contribution last_liquidity;
                  payStakingReward current_block last_block last_husd_contribution _sender;
                
                  e = { _eventname: "Burnt"; pool: token_address; address: _sender; amount: contribution_amount };
                  event e
                end
              end
            end
          end
        end
      end
    end
  end
end



transition SwapExactHUSDForToken( 
  token_address : ByStr20,
  husd_amount: Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  direction = HusdToToken;
  exact_side = ExactInput;
  exact_amount = husd_amount;
  limit_amount = min_token_amount;

  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end



transition SwapExactHUSDForTokens(
  token_address : ByStr20,
  husd_amount: Uint128,
  min_token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  direction = HusdToToken;
  exact_side = ExactInput;
  exact_amount = husd_amount;
  limit_amount = min_token_amount;

  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end

transition SwapExactTokensForHUSD(
  token_address : ByStr20,
  token_amount : Uint128,
  min_husd_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  direction = TokenToHusd;
  exact_side = ExactInput;
  exact_amount = token_amount;
  limit_amount = min_husd_amount;

  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end




transition SwapHUSDForExactTokens(
  token_address : ByStr20,
  max_husd_amount: Uint128,
  token_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)
  direction = HusdToToken;
  exact_side = ExactOutput;
  exact_amount = token_amount;
  limit_amount = max_husd_amount;


  e = { _eventname: "First Chweck" };
  event e;
                
  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end

transition SwapTokensForExactHUSD(
  token_address : ByStr20,
  max_token_amount : Uint128,
  husd_amount : Uint128,
  deadline_block : BNum,
  recipient_address : ByStr20
)


  e = { _eventname: "First Chweck" };
  event e;
  
  direction = TokenToHusd;
  exact_side = ExactOutput;
  exact_amount = husd_amount;
  limit_amount = max_token_amount;

  SwapUsingHUSD
    token_address
    direction
    exact_side
    exact_amount
    limit_amount
    deadline_block
    recipient_address
end

transition SwapExactTokensForTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  token0_amount : Uint128, (* the token0 amount to be sent in *)
  min_token1_amount : Uint128, (* min token0 amount that must be received for the txn to not revert *)
  deadline_block : BNum,
  recipient_address : ByStr20
)
  ThrowIfExpired deadline_block;
  ThrowIfZero token0_amount;
  ThrowIfZero min_token1_amount;

  after_fee <- output_after_fee;
  maybe_pool0 <- pools[token0_address];

  result0 =
    let direction = TokenToHusd in
    let exact_side = ExactInput in
    let limit_amount = None {Uint128} in
    let swap = Swap maybe_pool0 direction exact_side token0_amount limit_amount after_fee in
      resultFor swap;

  match result0 with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Result pool0 husd_intermediate_amount =>
    maybe_pool1 <- pools[token1_address];

    result1 =
      let direction = HusdToToken in
      let exact_side = ExactInput in
      let limit_amount = Some {Uint128} min_token1_amount in
      let swap = Swap maybe_pool1 direction exact_side husd_intermediate_amount limit_amount after_fee in
        resultFor swap;

    match result1 with
    | Error msg =>
      e = { _exception : msg };
      throw e
    | Result pool1 output_amount =>
      DoSwapTwice
        pool0
        token0_address
        pool1
        token1_address
        token0_amount
        husd_intermediate_amount
        output_amount
        recipient_address
    end
  end
end

transition SwapTokensForExactTokens(
  token0_address : ByStr20,
  token1_address : ByStr20,
  max_token0_amount : Uint128, (* the max token0 amount that may be sent in before the txn will revert *)
  token1_amount : Uint128, (* token1 amount to be received *)
  deadline_block : BNum,
  recipient_address : ByStr20
)
  ThrowIfExpired deadline_block;
  ThrowIfZero max_token0_amount;
  ThrowIfZero token1_amount;

  after_fee <- output_after_fee;
  maybe_pool1 <- pools[token1_address];

  result1 =
    let direction = HusdToToken in
    let exact_side = ExactOutput in
    let limit_amount = None {Uint128} in
    let swap = Swap maybe_pool1 direction exact_side token1_amount limit_amount after_fee in
      resultFor swap;

  match result1 with
  | Error msg =>
    e = { _exception : msg };
    throw e
  | Result pool1 husd_intermediate_amount =>
    maybe_pool0 <- pools[token0_address];

    result0 =
      let direction = TokenToHusd in
      let exact_side = ExactOutput in
      let limit_amount = Some {Uint128} max_token0_amount in
      let swap = Swap maybe_pool0 direction exact_side husd_intermediate_amount limit_amount after_fee in
        resultFor swap;

    match result0 with
    | Error msg =>
      e = { _exception : msg };
      throw e
    | Result pool0 input_amount =>
      DoSwapTwice
        pool0
        token0_address
        pool1
        token1_address
        input_amount
        husd_intermediate_amount
        token1_amount
        recipient_address
    end
  end
end

(* NEW TEST 4141414 *)